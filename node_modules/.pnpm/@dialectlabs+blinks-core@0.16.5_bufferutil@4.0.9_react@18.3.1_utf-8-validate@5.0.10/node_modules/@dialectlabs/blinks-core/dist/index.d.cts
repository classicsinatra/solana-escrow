import { ActionGetResponse, SignMessageData as SignMessageData$1, NextActionLink, PostNextActionLink, MessageNextActionPostRequest, NextActionPostRequest, NextAction, LinkedActionType, TypedActionParameter, ActionPostRequest, ActionPostResponse, GeneralParameterType, SelectableParameterType } from '@solana/actions-spec';
export * from '@solana/actions-spec';
export { Action as TypedAction } from '@solana/actions-spec';
import { Connection } from '@solana/web3.js';
import * as react_jsx_runtime from 'react/jsx-runtime';
import { ComponentType } from 'react';

interface DialectExperimentalFeatures {
    dialectExperimental?: {
        liveData?: {
            enabled: boolean;
            delayMs?: number;
        };
    };
}
type ExtendedActionGetResponse = ActionGetResponse & DialectExperimentalFeatures;

interface ActionContext {
    originalUrl: string;
    action: Action$1;
    actionType: 'trusted' | 'malicious' | 'unknown';
    triggeredLinkedAction: AbstractActionComponent;
}
interface IncomingActionConfig {
    rpcUrl: string;
    adapter: Pick<ActionAdapter, 'connect' | 'signTransaction' | 'signMessage'> & Partial<Pick<ActionAdapter, 'metadata'>>;
}
/**
 * Metadata for an action adapter.
 *
 * @property supportedBlockchainIds List of CAIP-2 blockchain IDs the adapter supports.
 *
 * @see {BlockchainIds}
 */
interface ActionAdapterMetadata {
    /**
     * List of CAIP-2 blockchain IDs the adapter supports.
     */
    supportedBlockchainIds: string[];
}
interface ActionAdapter {
    metadata: ActionAdapterMetadata;
    connect: (context: ActionContext) => Promise<string | null>;
    signTransaction: (tx: string, context: ActionContext) => Promise<{
        signature: string;
    } | {
        error: string;
    }>;
    confirmTransaction: (signature: string, context: ActionContext) => Promise<void>;
    signMessage: (data: string | SignMessageData$1, context: ActionContext) => Promise<{
        signature: string;
    } | {
        error: string;
    }>;
}
declare class ActionConfig implements ActionAdapter {
    private adapter;
    private static readonly CONFIRM_TIMEOUT_MS;
    private static readonly DEFAULT_METADATA;
    private connection;
    constructor(rpcUrlOrConnection: string | Connection, adapter: IncomingActionConfig['adapter']);
    get metadata(): ActionAdapterMetadata;
    signTransaction(tx: string, context: ActionContext): Promise<{
        signature: string;
    } | {
        error: string;
    }>;
    confirmTransaction(signature: string): Promise<void>;
    signMessage(data: string | SignMessageData$1, context: ActionContext): Promise<{
        signature: string;
    } | {
        error: string;
    }>;
    connect(context: ActionContext): Promise<string | null>;
}

/**
 * Max spec version the Blink client supports.
 */
declare const MAX_SUPPORTED_ACTION_VERSION: string;
declare const DEFAULT_SUPPORTED_BLOCKCHAIN_IDS: string[];
/**
 * Baseline action version to be used when not set by action provider.
 * Defaults to latest release that doesn't support versioning.
 */
declare const BASELINE_ACTION_VERSION = "2.2";
/**
 * Baseline blockchain IDs to be used when not set by action provider.
 * Defaults to Solana mainnet.
 */
declare const BASELINE_ACTION_BLOCKCHAIN_IDS: string[];
type IsVersionSupportedParams = {
    actionVersion: string;
    supportedActionVersion: string;
};
type IsBlockchainIdSupportedParams = {
    actionBlockchainIds: string[];
    supportedBlockchainIds: string[];
};
type ActionSupportability = {
    isSupported: true;
} | {
    isSupported: false;
    message: string;
};
type ActionSupportStrategy = (action: Action$1, adapter: ActionAdapter) => Promise<ActionSupportability>;
/**
 * Default implementation for checking if an action is supported.
 * Checks if the action version and the action blockchain IDs are supported by blink.
 * @param action Action.
 * @param adapter Action adapter.
 *
 * @see {isVersionSupported}
 * @see {isBlockchainSupported}
 */
declare const defaultActionSupportStrategy: ActionSupportStrategy;
/**
 * Check if the action version is supported by blink.
 * @param supportedActionVersion The version the blink supports.
 * @param actionVersion The version of the action.
 *
 * @returns `true` if the action version is less than or equal to the supported ignoring patch version, `false` otherwise.
 */
declare function isVersionSupported({ supportedActionVersion, actionVersion, }: IsVersionSupportedParams): boolean;
/**
 * Check if action blockchain IDs are supported by the blink.
 *
 * @param supportedBlockchainIds List of CAIP-2 blockchain IDs the client supports.
 * @param actionBlockchainIds List of CAIP-2 blockchain IDs the action supports.
 *
 * @returns `true` if all action blockchain IDs are supported by blink, `false` otherwise.
 *
 * @see BlockchainIds
 */
declare function isBlockchainSupported({ supportedBlockchainIds, actionBlockchainIds, }: IsBlockchainIdSupportedParams): boolean;

interface ActionMetadata {
    blockchainIds?: string[];
    version?: string;
}
interface LiveData {
    enabled: boolean;
    delayMs?: number;
}
declare class Action$1 {
    private readonly _url;
    private readonly _data;
    private readonly _metadata;
    private readonly _supportStrategy;
    private readonly _chainMetadata;
    private readonly _id?;
    private readonly _experimental?;
    private readonly _actions;
    private constructor();
    get liveData_experimental(): Required<LiveData> | null;
    get id(): string | undefined;
    get isChained(): boolean;
    get isInline(): boolean;
    get type(): "action" | "completed";
    get url(): string;
    get icon(): string;
    get title(): string;
    get description(): string;
    get disabled(): boolean;
    get actions(): AbstractActionComponent[];
    get error(): string | null;
    get metadata(): ActionMetadata;
    isSupported(adapter: ActionAdapter): Promise<{
        isSupported: true;
    } | {
        isSupported: boolean;
        message: string;
    }>;
    chain<N extends NextActionLink>(next: N, chainData?: N extends PostNextActionLink ? MessageNextActionPostRequest | NextActionPostRequest : never): Promise<Action$1 | null>;
    static hydrate(url: string, data: NextAction, metadata: ActionMetadata, supportStrategy: ActionSupportStrategy): Action$1;
    private static _fetch;
    static fetch(apiUrl: string, supportStrategy?: ActionSupportStrategy): Promise<Action$1>;
    refresh(): Promise<Action$1>;
    withUpdate(update: {
        supportStrategy?: ActionSupportStrategy;
    }): Action$1;
}

declare abstract class AbstractActionComponent {
    protected _parent: Action$1;
    protected _label: string;
    protected _href: string;
    protected _type: LinkedActionType;
    protected _parameters?: TypedActionParameter[] | undefined;
    protected constructor(_parent: Action$1, _label: string, _href: string, _type: LinkedActionType, _parameters?: TypedActionParameter[] | undefined);
    get parent(): Action$1;
    get label(): string;
    get parameters(): TypedActionParameter[];
    get type(): LinkedActionType;
    abstract get href(): string;
    protected abstract buildBody(account: string): ActionPostRequest;
    post(account: string): Promise<ActionPostResponse>;
}

declare class ButtonActionComponent extends AbstractActionComponent {
    protected _parent: Action$1;
    protected _label: string;
    protected _href: string;
    protected _type: LinkedActionType;
    protected _parameters?: TypedActionParameter[] | undefined;
    protected _parentComponent?: AbstractActionComponent | undefined;
    constructor(_parent: Action$1, _label: string, _href: string, _type: LinkedActionType, _parameters?: TypedActionParameter[] | undefined, _parentComponent?: AbstractActionComponent | undefined);
    get parentComponent(): AbstractActionComponent | null;
    protected buildBody(account: string): ActionPostRequest;
    get href(): string;
}

declare class SingleValueActionComponent extends AbstractActionComponent {
    protected _parent: Action$1;
    protected _label: string;
    protected _href: string;
    protected _type: LinkedActionType;
    protected _parameters?: TypedActionParameter[] | undefined;
    protected _parentComponent?: AbstractActionComponent | undefined;
    private parameterValue;
    constructor(_parent: Action$1, _label: string, _href: string, _type: LinkedActionType, _parameters?: TypedActionParameter[] | undefined, _parentComponent?: AbstractActionComponent | undefined);
    get parentComponent(): AbstractActionComponent | null;
    protected buildBody(account: string): ActionPostRequest<any>;
    get parameter(): TypedActionParameter<GeneralParameterType>;
    setValue(value: string): void;
    get href(): string;
    toButtonActionComponent(): ButtonActionComponent;
}

declare class FormActionComponent extends AbstractActionComponent {
    protected _parent: Action$1;
    protected _label: string;
    protected _href: string;
    protected _type: LinkedActionType;
    protected _parameters?: TypedActionParameter[] | undefined;
    protected _parentComponent?: AbstractActionComponent | undefined;
    private parameterValues;
    constructor(_parent: Action$1, _label: string, _href: string, _type: LinkedActionType, _parameters?: TypedActionParameter[] | undefined, _parentComponent?: AbstractActionComponent | undefined);
    get parentComponent(): AbstractActionComponent | null;
    protected buildBody(account: string): ActionPostRequest<any>;
    get href(): string;
    setValue(value: string | Array<string>, name: string): void;
    toButtonActionComponent(): ButtonActionComponent;
    toInputActionComponent(paramName: string): SingleValueActionComponent;
}

declare class MultiValueActionComponent extends AbstractActionComponent {
    protected _parent: Action$1;
    protected _label: string;
    protected _href: string;
    protected _type: LinkedActionType;
    protected _parameters?: TypedActionParameter[] | undefined;
    protected _parentComponent?: AbstractActionComponent | undefined;
    private parameterValue;
    constructor(_parent: Action$1, _label: string, _href: string, _type: LinkedActionType, _parameters?: TypedActionParameter[] | undefined, _parentComponent?: AbstractActionComponent | undefined);
    get parentComponent(): AbstractActionComponent | null;
    protected buildBody(account: string): ActionPostRequest<any>;
    get isMultiOptions(): boolean;
    get parameter(): TypedActionParameter<SelectableParameterType>;
    setValue(value: string | Array<string>): void;
    get href(): string;
    toButtonActionComponent(): ButtonActionComponent;
}

declare const isPatternAllowed: (parameter: TypedActionParameter) => boolean;
declare const isParameterSelectable: (parameter: TypedActionParameter) => parameter is TypedActionParameter<SelectableParameterType>;

type SignMessageData = SignMessageData$1;
interface SignMessageVerificationOptions {
    expectedAddress?: string;
    expectedDomains?: string[];
    expectedChainIds?: string[];
    issuedAtThreshold?: number;
}
declare enum SignMessageVerificationErrorType {
    ADDRESS_MISMATCH = "ADDRESS_MISMATCH",
    DOMAIN_MISMATCH = "DOMAIN_MISMATCH",
    CHAIN_ID_MISMATCH = "CHAIN_ID_MISMATCH",
    ISSUED_TOO_FAR_IN_THE_PAST = "ISSUED_TOO_FAR_IN_THE_PAST",
    ISSUED_TOO_FAR_IN_THE_FUTURE = "ISSUED_TOO_FAR_IN_THE_FUTURE",
    INVALID_DATA = "INVALID_DATA"
}
/**
 * Create a human-readable message text for the user to sign.
 *
 * @param input The data to be signed.
 * @returns The message text.
 */
declare function createSignMessageText(input: SignMessageData): string;
/**
 * Parse the sign message text to extract the data to be signed.
 * @param text The message text to be parsed.
 */
declare function parseSignMessageText(text: string): SignMessageData | null;
/**
 * Verify the sign message data before signing.
 * @param data The data to be signed.
 * @param opts Options for verification, including the expected address, chainId, issuedAt, and domains.
 *
 * @returns An array of errors if the verification fails.
 */
declare function verifySignMessageData(data: SignMessageData, opts: SignMessageVerificationOptions): SignMessageVerificationErrorType[];

interface ActionCallbacksConfig {
    onActionMount: (action: Action$1, originalUrl: string, type: 'trusted' | 'malicious' | 'unknown') => void;
    onActionCancel: (action: Action$1, trigger: AbstractActionComponent, reason: string) => void;
    onActionChain: (previousAction: Action$1, chainedAction: Action$1, chainTrigger: AbstractActionComponent, chainType: LinkedActionType, signature?: string) => void;
    onActionComplete: (action: Action$1, trigger: AbstractActionComponent, signature?: string) => void;
    onActionError: (action: Action$1, trigger: AbstractActionComponent, reason: string, signature?: string) => void;
}

type LookupType = 'action' | 'website' | 'interstitial';
declare class ActionsRegistry {
    private static instance;
    private actionsByHost;
    private websitesByHost;
    private interstitialsByHost;
    private intervalId;
    private constructor();
    static getInstance(config?: ActionsRegistryConfig): ActionsRegistry;
    init(): Promise<void>;
    stopRefresh(): void;
    refresh(): Promise<void>;
    lookup(url: string | URL, type?: LookupType): RegisteredEntity | null;
    private lookupAction;
    private lookupWebsite;
    private lookupInterstitial;
}
interface ActionsRegistryConfig {
    actions: RegisteredEntity[];
    websites: RegisteredEntity[];
    interstitials: RegisteredEntity[];
}
interface RegisteredEntity {
    host: string;
    state: 'trusted' | 'malicious';
}
type SecurityActionState = RegisteredEntity['state'] | 'unknown';
declare const mergeActionStates: (...states: SecurityActionState[]) => SecurityActionState;
declare const getExtendedActionState: (actionOrUrl: Action$1 | string) => SecurityActionState;
declare const getExtendedWebsiteState: (url: string) => SecurityActionState;
declare const getExtendedInterstitialState: (url: string) => SecurityActionState;

interface SolanaPaySpecGetResponse {
    label: string;
    icon: string;
}
interface SolanaPaySpecPostRequestBody {
    account: string;
}
interface SolanaPaySpecPostResponse {
    transaction: string;
    message?: string;
    redirect?: string;
}

/**
 * CAIP-2 Blockchain IDs.
 */
declare const BlockchainIds: {
    SOLANA_MAINNET: string;
    SOLANA_DEVNET: string;
    SOLANA_TESTNET: string;
    ETHEREUM_MAINNET: string;
    MONAD_DEVNET: string;
};

declare const BLINK_CLIENT_KEY_HEADER = "x-blink-client-key";
declare function setClientKey(key: string): void;

declare const SOLANA_ACTION_PREFIX: RegExp;

type IsInterstitialResult = {
    isInterstitial: true;
    decodedActionUrl: string;
} | {
    isInterstitial: false;
};
declare function isInterstitial(url: string | URL): IsInterstitialResult;

type ProxifiedResult = {
    readonly url: URL;
    readonly headers: Record<string, string>;
};
declare function setProxyUrl(url: string): void;
declare function proxify(url: string): ProxifiedResult;
declare function proxifyImage(url: string): ProxifiedResult;

type SecurityLevel = 'only-trusted' | 'non-malicious' | 'all';
declare const checkSecurity: (state: SecurityActionState, securityLevel: SecurityLevel) => boolean;

type Action = {
    pathPattern: string;
    apiPath: string;
};
type ActionsJsonConfig = {
    rules: Action[];
};
declare class ActionsURLMapper {
    private config;
    constructor(config: ActionsJsonConfig);
    mapUrl(url: string | URL): string | null;
    private isExactMatch;
    private matchPattern;
    private constructMappedUrl;
}
declare function unfurlUrlToActionApiUrl(actionUrl: URL | string): Promise<string | null>;

type BlinkSecurityState = SecurityActionState;
declare enum DisclaimerType {
    BLOCKED = "blocked",
    UNKNOWN = "unknown"
}
type Disclaimer = {
    type: DisclaimerType.BLOCKED;
    ignorable: boolean;
    hidden: boolean;
    onSkip: () => void;
} | {
    type: DisclaimerType.UNKNOWN;
    ignorable: boolean;
};
interface BlinkCaption {
    type: 'success' | 'error';
    text: string;
}
type ExtraExecutionData = {
    type: Extract<LinkedActionType, 'external-link'>;
    data: {
        externalLink: string;
    };
    onNext: () => void;
    onCancel?: () => void;
};
interface BaseBlinkLayoutProps {
    id?: string;
    securityState: BlinkSecurityState;
    action: Action$1;
    component?: AbstractActionComponent | null;
    websiteUrl?: string | null;
    websiteText?: string | null;
    disclaimer?: Disclaimer | null;
    caption?: BlinkCaption | null;
    executeFn: (component: AbstractActionComponent, params?: Record<string, string | string[]>) => Promise<ExtraExecutionData | void>;
    executionStatus: ExecutionStatus;
    executingAction?: AbstractActionComponent | null;
    supportability: ActionSupportability;
}
type ExecutionStatus = 'blocked' | 'checking-supportability' | 'idle' | 'executing' | 'success' | 'error';
interface ExecutionState {
    status: ExecutionStatus;
    checkingSupportability?: boolean;
    executingAction?: AbstractActionComponent | null;
    errorMessage?: string | null;
    successMessage?: string | null;
}
declare enum ExecutionType {
    CHECK_SUPPORTABILITY = "CHECK_SUPPORTABILITY",
    INITIATE = "INITIATE",
    FINISH = "FINISH",
    FAIL = "FAIL",
    RESET = "RESET",
    SOFT_RESET = "SOFT_RESET",
    UNBLOCK = "UNBLOCK",
    BLOCK = "BLOCK"
}
type Source = 'websites' | 'interstitials' | 'actions';
type NormalizedSecurityLevel = Record<Source, SecurityLevel>;
interface BlinkContainerProps {
    action: Action$1;
    adapter: ActionAdapter;
    selector?: (currentAction: Action$1) => AbstractActionComponent | null;
    websiteUrl?: string | null;
    websiteText?: string | null;
    callbacks?: Partial<ActionCallbacksConfig>;
    securityLevel?: SecurityLevel | NormalizedSecurityLevel;
    Layout: ComponentType<BaseBlinkLayoutProps>;
}
declare const BlinkContainer: ({ action: initialAction, adapter, websiteUrl, websiteText, callbacks, securityLevel, Layout, selector, }: BlinkContainerProps) => react_jsx_runtime.JSX.Element;

interface UseActionOptions {
    url: string | URL;
    securityRegistryRefreshInterval?: number;
    supportStrategy?: ActionSupportStrategy;
}
declare function useAction({ url, supportStrategy, }: UseActionOptions): {
    action: Action$1 | null;
    isLoading: boolean;
    refresh: () => () => void;
};

declare function useActionsRegistryInterval(): {
    isRegistryLoaded: boolean;
};

interface UseBlinkListOptions {
    id: string;
    wallet?: string;
}
interface BlinkList {
    entries: BlinkListEntry[];
}
interface BlinkListEntry {
    id: string;
    title: string;
    description: string;
    blinkUrl: string;
    metadataUrl?: string;
    websiteUrl?: string;
    websiteText?: string;
    image: string;
    icon?: string;
}
declare const useBlinkList: ({ id, wallet }: UseBlinkListOptions) => {
    loading: boolean;
    refetch: () => () => void;
    data: BlinkListEntry[];
};
declare function fetchBlinkList(id: string, wallet: string | undefined): Promise<BlinkList>;

interface UseMetadataArgs {
    wallet?: string;
    url: string;
}
interface BlinkMetadata {
    rows: MetadataRow[];
    extendedDescription?: string;
}
interface MetadataRow {
    key: string;
    title: string;
    value: string;
    icon?: string;
    url?: string;
}
declare const useMetadata: ({ url, wallet }: UseMetadataArgs) => {
    loading: boolean;
    refetch: () => () => void;
    data: BlinkMetadata | undefined;
};
declare function fetchMetadata(url: string, wallet?: string): Promise<BlinkMetadata>;

export { AbstractActionComponent, Action$1 as Action, type ActionAdapter, type ActionAdapterMetadata, type ActionCallbacksConfig, ActionConfig, type ActionContext, type ActionSupportStrategy, type ActionSupportability, type ActionsJsonConfig, ActionsRegistry, type ActionsRegistryConfig, ActionsURLMapper, BASELINE_ACTION_BLOCKCHAIN_IDS, BASELINE_ACTION_VERSION, BLINK_CLIENT_KEY_HEADER, type BaseBlinkLayoutProps, type BlinkCaption, BlinkContainer, type BlinkContainerProps, type BlinkList, type BlinkListEntry, type BlinkMetadata, type BlinkSecurityState, BlockchainIds, ButtonActionComponent, DEFAULT_SUPPORTED_BLOCKCHAIN_IDS, type DialectExperimentalFeatures, type Disclaimer, DisclaimerType, type ExecutionState, type ExecutionStatus, ExecutionType, type ExtendedActionGetResponse, type ExtraExecutionData, FormActionComponent, type IncomingActionConfig, type IsInterstitialResult, type LookupType, MAX_SUPPORTED_ACTION_VERSION, type MetadataRow, MultiValueActionComponent, type RegisteredEntity, SOLANA_ACTION_PREFIX, type SecurityActionState, type SecurityLevel, type SignMessageData, SignMessageVerificationErrorType, type SignMessageVerificationOptions, SingleValueActionComponent, type SolanaPaySpecGetResponse, type SolanaPaySpecPostRequestBody, type SolanaPaySpecPostResponse, checkSecurity, createSignMessageText, defaultActionSupportStrategy, fetchBlinkList, fetchMetadata, getExtendedActionState, getExtendedInterstitialState, getExtendedWebsiteState, isBlockchainSupported, isInterstitial, isParameterSelectable, isPatternAllowed, isVersionSupported, mergeActionStates, parseSignMessageText, proxify, proxifyImage, setClientKey, setProxyUrl, unfurlUrlToActionApiUrl, useAction, useActionsRegistryInterval, useBlinkList, useMetadata, verifySignMessageData };
