import {
  Blink
} from "../chunk-4DYUAYM4.js";

// src/ext/twitter.tsx
import {
  Action,
  ActionsRegistry,
  ActionsURLMapper,
  checkSecurity,
  defaultActionSupportStrategy,
  getExtendedActionState,
  getExtendedInterstitialState,
  getExtendedWebsiteState,
  isInterstitial,
  proxify
} from "@dialectlabs/blinks-core";
import { createRoot } from "react-dom/client";
import { jsx } from "react/jsx-runtime";
var noop = () => {
};
var DEFAULT_OPTIONS = {
  securityLevel: "only-trusted",
  supportStrategy: defaultActionSupportStrategy
};
var normalizeOptions = (options) => {
  return {
    ...DEFAULT_OPTIONS,
    ...options,
    securityLevel: (() => {
      if (!options.securityLevel) {
        return {
          websites: DEFAULT_OPTIONS.securityLevel,
          interstitials: DEFAULT_OPTIONS.securityLevel,
          actions: DEFAULT_OPTIONS.securityLevel
        };
      }
      if (typeof options.securityLevel === "string") {
        return {
          websites: options.securityLevel,
          interstitials: options.securityLevel,
          actions: options.securityLevel
        };
      }
      return options.securityLevel;
    })()
  };
};
function setupTwitterObserver(config, callbacks = {}, options = DEFAULT_OPTIONS) {
  const mergedOptions = normalizeOptions(options);
  const twitterReactRoot = document.getElementById("react-root");
  const refreshRegistry = async () => {
    return ActionsRegistry.getInstance().init();
  };
  refreshRegistry().then(() => {
    const observer = new MutationObserver((mutations) => {
      for (let i = 0; i < mutations.length; i++) {
        const mutation = mutations[i];
        for (let j = 0; j < mutation.addedNodes.length; j++) {
          const node = mutation.addedNodes[j];
          if (node.nodeType !== Node.ELEMENT_NODE) {
            return;
          }
          handleNewNode(
            node,
            config,
            callbacks,
            mergedOptions
          ).catch(noop);
        }
      }
    });
    observer.observe(twitterReactRoot, { childList: true, subtree: true });
  });
}
async function handleNewNode(node, config, callbacks, options) {
  const element = node;
  if (!element || element.localName !== "div") {
    return;
  }
  let anchor;
  const linkPreview = findLinkPreview(element);
  let container = findContainerInTweet(
    linkPreview?.card ?? element,
    Boolean(linkPreview)
  );
  if (linkPreview) {
    anchor = linkPreview.anchor;
    container && container.remove();
    container = linkPreview.card.parentElement;
  } else {
    if (container) {
      return;
    }
    const link = findLastLinkInText(element);
    if (link) {
      anchor = link.anchor;
      container = getContainerForLink(link.tweetText);
    }
  }
  if (!anchor || !container) return;
  const shortenedUrl = anchor.href;
  const actionUrl = await resolveTwitterShortenedUrl(shortenedUrl);
  const interstitialData = isInterstitial(actionUrl);
  let actionApiUrl;
  if (interstitialData.isInterstitial) {
    const interstitialState = getExtendedInterstitialState(
      actionUrl.toString()
    );
    if (!checkSecurity(interstitialState, options.securityLevel.interstitials)) {
      return;
    }
    actionApiUrl = interstitialData.decodedActionUrl;
  } else {
    const websiteState = getExtendedWebsiteState(actionUrl.toString());
    if (!checkSecurity(websiteState, options.securityLevel.websites)) {
      return;
    }
    const actionsJsonUrl = actionUrl.origin + "/actions.json";
    const { url: proxyUrl, headers: proxyHeaders } = proxify(actionsJsonUrl);
    const actionsJson = await fetch(proxyUrl, {
      headers: proxyHeaders
    }).then((res) => res.json());
    const actionsUrlMapper = new ActionsURLMapper(actionsJson);
    actionApiUrl = actionsUrlMapper.mapUrl(actionUrl);
  }
  const state = actionApiUrl ? getExtendedActionState(actionApiUrl) : null;
  if (!actionApiUrl || !state || !checkSecurity(state, options.securityLevel.actions)) {
    return;
  }
  const action = await Action.fetch(
    actionApiUrl,
    options.supportStrategy
  ).catch(noop);
  if (!action) {
    return;
  }
  const { container: actionContainer, reactRoot } = createAction({
    config,
    originalUrl: actionUrl,
    action,
    callbacks,
    options,
    isInterstitial: interstitialData.isInterstitial
  });
  addStyles(container).replaceChildren(actionContainer);
  new MutationObserver((mutations, observer) => {
    for (const mutation of mutations) {
      for (const removedNode of Array.from(mutation.removedNodes)) {
        if (removedNode === actionContainer || !document.body.contains(actionContainer)) {
          reactRoot.unmount();
          observer.disconnect();
        }
      }
    }
  }).observe(document.body, { childList: true, subtree: true });
}
function createAction({
  originalUrl,
  action,
  callbacks,
  options,
  config
}) {
  const container = document.createElement("div");
  container.className = "dialect-action-root-container";
  const actionRoot = createRoot(container);
  actionRoot.render(
    /* @__PURE__ */ jsx("div", { onClick: (e) => e.stopPropagation(), children: /* @__PURE__ */ jsx(
      Blink,
      {
        adapter: config,
        stylePreset: resolveXStylePreset(),
        action,
        websiteUrl: originalUrl.toString(),
        websiteText: originalUrl.hostname,
        callbacks,
        securityLevel: options.securityLevel
      }
    ) })
  );
  return { container, reactRoot: actionRoot };
}
var resolveXStylePreset = () => {
  const colorScheme = document.querySelector("html")?.style.colorScheme;
  if (colorScheme) {
    return colorScheme === "dark" ? "x-dark" : "x-light";
  }
  const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
  return prefersDark ? "x-dark" : "x-light";
};
async function resolveTwitterShortenedUrl(shortenedUrl) {
  const res = await fetch(shortenedUrl);
  const html = await res.text();
  const parser = new DOMParser();
  const doc = parser.parseFromString(html, "text/html");
  const actionUrl = doc.querySelector("title")?.textContent;
  return new URL(actionUrl);
}
function findElementByTestId(element, testId) {
  if (element.attributes.getNamedItem("data-testid")?.value === testId) {
    return element;
  }
  return element.querySelector(`[data-testid="${testId}"]`);
}
function findContainerInTweet(element, searchUp) {
  const message = searchUp ? element.closest(`[data-testid="tweet"]`) ?? element.closest(`[data-testid="messageEntry"]`) : findElementByTestId(element, "tweet") ?? findElementByTestId(element, "messageEntry");
  if (message) {
    return message.querySelector(".dialect-wrapper");
  }
  return null;
}
function findLinkPreview(element) {
  const card = findElementByTestId(element, "card.wrapper");
  if (!card) {
    return null;
  }
  const anchor = card.children[0]?.children[0];
  return anchor ? { anchor, card } : null;
}
function findLastLinkInText(element) {
  const tweetText = findElementByTestId(element, "tweetText");
  if (!tweetText) {
    return null;
  }
  const links = tweetText.getElementsByTagName("a");
  if (links.length > 0) {
    const anchor = links[links.length - 1];
    return { anchor, tweetText };
  }
  return null;
}
function getContainerForLink(tweetText) {
  const root = document.createElement("div");
  root.className = "dialect-wrapper";
  const dm = tweetText.closest(`[data-testid="messageEntry"]`);
  if (dm) {
    root.classList.add("dialect-dm");
    tweetText.parentElement?.parentElement?.prepend(root);
  } else {
    tweetText.parentElement?.append(root);
  }
  return root;
}
function addStyles(element) {
  if (element && element.classList.contains("dialect-wrapper")) {
    element.style.marginTop = "12px";
    if (element.classList.contains("dialect-dm")) {
      element.style.marginBottom = "8px";
      element.style.width = "100%";
      element.style.minWidth = "350px";
    }
  }
  return element;
}
export {
  setupTwitterObserver
};
