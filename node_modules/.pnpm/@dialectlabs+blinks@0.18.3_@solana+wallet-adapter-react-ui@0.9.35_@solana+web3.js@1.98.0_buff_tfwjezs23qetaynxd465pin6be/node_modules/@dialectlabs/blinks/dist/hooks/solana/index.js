// src/hooks/solana/useActionSolanaWalletAdapter.ts
import {
  ActionConfig,
  createSignMessageText,
  verifySignMessageData
} from "@dialectlabs/blinks-core";
import { useWallet } from "@solana/wallet-adapter-react";
import { useWalletModal } from "@solana/wallet-adapter-react-ui";
import { Connection, VersionedTransaction } from "@solana/web3.js";
import bs58 from "bs58";
import { useMemo } from "react";

// src/utils/base64.ts
var decodeBase64 = (str) => {
  const binary = atob(str);
  const bytes = new Uint8Array(new ArrayBuffer(binary.length));
  const half = binary.length / 2;
  for (let i = 0, j = binary.length - 1; i <= half; i++, j--) {
    bytes[i] = binary.charCodeAt(i);
    bytes[j] = binary.charCodeAt(j);
  }
  return bytes;
};

// src/hooks/solana/useActionSolanaWalletAdapter.ts
function useActionSolanaWalletAdapter(rpcUrlOrConnection) {
  const wallet = useWallet();
  const walletModal = useWalletModal();
  const finalConnection = useMemo(() => {
    return typeof rpcUrlOrConnection === "string" ? new Connection(rpcUrlOrConnection, "confirmed") : rpcUrlOrConnection;
  }, [rpcUrlOrConnection]);
  const adapter = useMemo(() => {
    function verifySignDataValidity(data, opts) {
      if (typeof data === "string") {
        return true;
      }
      const errors = verifySignMessageData(data, opts);
      if (errors.length > 0) {
        console.warn(
          `[@dialectlabs/blinks] Sign message data verification error: ${errors.join(", ")}`
        );
      }
      return errors.length === 0;
    }
    return new ActionConfig(finalConnection, {
      connect: async () => {
        try {
          await wallet.connect();
        } catch {
          walletModal.setVisible(true);
          return null;
        }
        return wallet.publicKey?.toBase58() ?? null;
      },
      signTransaction: async (txData) => {
        try {
          const tx = await wallet.sendTransaction(
            VersionedTransaction.deserialize(decodeBase64(txData)),
            finalConnection
          );
          return { signature: tx };
        } catch {
          return { error: "Signing failed." };
        }
      },
      signMessage: async (data) => {
        if (!wallet.signMessage || !wallet.publicKey) {
          return { error: "Signing failed." };
        }
        try {
          const isSignDataValid = verifySignDataValidity(data, {
            expectedAddress: wallet.publicKey.toString()
          });
          if (!isSignDataValid) {
            return { error: "Signing failed." };
          }
          const text = typeof data === "string" ? data : createSignMessageText(data);
          const encoded = new TextEncoder().encode(text);
          const signed = await wallet.signMessage(encoded);
          const encodedSignature = bs58.encode(signed);
          return { signature: encodedSignature };
        } catch (e) {
          return { error: "Signing failed." };
        }
      }
    });
  }, [finalConnection, wallet, walletModal]);
  return { adapter };
}
export {
  useActionSolanaWalletAdapter
};
